#+TITLE: Generating (Secure) Pseudo-Random Data with SPARKLE512
#+Time-stamp: <2024-08-20 17:32:32 lperrin>


* Design Approach
** Sponge Construction
*** Indirect Injection
*** Indirect Squeezing
The following SAGE script displays the corresponding matrix and shows
that it indeed has full rank.

#+BEGIN_SRC python :tangle sparklyRG/indirect.py
#!/usr/bin/sage

from sage.all import GF, Matrix

M = Matrix(GF(2), 8, 8, [
    [1*(j in [i, (i+1)%8, (i+5)%8]) for j in range(0, 8)]
    for i in range(0, 8)
])
print(M)
print(M.rank())

#+END_SRC

** Varying Security Levels
*** Full blown XOF (Esch)
- Rate :: 384 bits
- Rounds :: 8
- Output method :: Truncation
*** Entropy Diffusion Function (key schedule)
- Rate :: 384 bits
- Rounds :: 4
- Output method :: Linear Leakage
*** Unsafe but faster
- Rate :: 384 bits
- Rounds :: 2
- Output method :: Linear Leakage
* Core Implementation
** High Level Interface
*** The Class
Let us first describe at a high level the way the SPARKLE-core
works. It implements a sponge-based construction, meaning that it has
an internal state of a fixed size (here, 512 bits, corresponding to
two arrays of eight 32-bit words each). In order to manipulate such
concepts, we need the C++ libraries =vector= and =cstdint=.
#+BEGIN_SRC cpp :tangle sparklyRG/sparkle512.hpp
#include<vector>
#include<cstdint>
#+END_SRC

We also need to put some basic macros from the [[https://github.com/cryptolu/sparkle/blob/master/software/sparkle/sparkle.c][original SPARKLE
reference implementation]]: =ROT= is just a 32-bit rotation, =ELL= is a
linear permutation operating on 32-bit words, and =RCON= contains
round constants (they were derived from the digits of the math
constant *e* in order to optimize the probabilities of the best
differential trails).

#+BEGIN_SRC cpp :tangle sparklyRG/sparkle512.hpp
#define ROT(x, n) (((x) >> (n)) | ((x) << (32-(n))))
#define ELL(x) (ROT(((x) ^ ((x) << 16)), 16))

#define N_BRANCHES 8

static const uint32_t RCON[N_BRANCHES] = {
    0xB7E15162, 0xBF715880, 0x38B4DA56, 0x324E7738,
	0xBB1185EB, 0x4F7C7B57, 0xCFBFA1C8, 0xC2B3293D
	};
#+END_SRC


Since we have an internal state that is operated upon by a permutation
and from which the leakage functions are non trivial, a natural
approach in C++ is to make an object. Its attributes and methods will
be described below (namely [[*Attributes][here]] and [[*Methods][here]]).

#+BEGIN_SRC cpp :tangle sparklyRG/sparkle512.hpp :noweb yes
class Sparkle512core {
private:
    <<attributes>>
public:
    <<methods>>
};
#+END_SRC

*** Attributes

The internal state is stored in a vector of 32-bit unsigned integers
(=uint32_t=). However, since the higher level methods will need to
interact with bytes rather than 32-bit integers, we also keep another
attribute: =entropy_tank=.  Its purpose is two-fold:
1. to be a vector of booleans rather than an array of 32-bit integers,
   which will unable an easier access to its content by the higher
   level functions, and
2. as we do a more complex squeezing than a mere copy, it will receive
   the output of this operation.
To avoid costly memory management, we don't change its size as it is
emptied (i.e., no "pop"). Instead, we use an integer (the
=entropy_cursor=) to keep track of where we are in it. Once it reaches
the end of the =entropy_tank=, we need to recharge it by calling the
permutation on the internal state, and then squeezing the internal
state to get it. While each entry in the =entropy_tank= is a single
bit (0 or 1), it is an array of =uint64_t= to avoid casting issues
when we use it to rebuild an output of the PRNG.


#+NAME: attributes
#+BEGIN_SRC cpp
unsigned int steps;
std::vector<uint32_t> state;
std::vector<uint64_t> entropy_tank;
unsigned int entropy_cursor;
#+END_SRC

*** Methods
The interface of this class is simple as we only want to do three
things:
1. initialize the object (contructor) by specifying the number of
   steps and the size of the output rate, i.e. the number of bytes
   that can be read before we need to update the state;
2. initialize the internal state using an external source of entropy
   (be it some fixed byte array for reproducibility, a pid/time-stamp
   in some simulations, or a more secure seed that we want to expand),
   an operation which is achieved by "absorbing" data into the state
   (see the explanations on the sponge construction [[*Sponge Construction][above]]); and
   perhaps most importantly,
3. output a pseudo-random unsigned integer of a given bit-length (at
   most 64).

However, in order for the class to play with SAGE, it needs to have a
constructor without argument. Thus, we will split the logic of
construction into two: a constructor (which doesn't do much), and a
=setup= function that actually takes arguments and does what's needed.

Along with these high level functions, we need lower level routines to
help implement them: =_permute()=, which updates the internal state
using the given number of SPARKLE512 steps, and =_squeeze=, which
squeezes its content into the =entropy_tank=.

#+NAME: methods
#+BEGIN_SRC cpp
Sparkle512core();
void setup(const unsigned int _steps, const unsigned int _output_rate);
void absorb(const std::vector<uint8_t> byte_array);
uint64_t get_n_bit_unsigned_integer(const unsigned int n);

void _squeeze();
void _permute();
#+END_SRC

** Implementing the Permutation and its Interface

Let us now implement all these methods. Classically, this will go in a
=.cpp= file that imports the header.
#+BEGIN_SRC cpp :tangle sparklyRG/sparkle512.cpp
#include "sparkle512.hpp"  
#+END_SRC

*** Constructor and Setup
This one is particularly straight-forward as we don't do much. To set
the attributes, we instead use the following function. The size of
=state= is not negotiable since we use SPARKLE512, so we can already
build this attribute here, along with the =entropy_cursor=.

#+BEGIN_SRC cpp :tangle sparklyRG/sparkle512.cpp
Sparkle512core::Sparkle512core():
    steps(0),
    state(2*N_BRANCHES, 0),
    entropy_tank(0, 0),
    entropy_cursor(0) {}

#+END_SRC

The other attributes are set using the =setup= method.

#+BEGIN_SRC cpp :tangle sparklyRG/sparkle512.cpp
void Sparkle512core::setup(const unsigned int _steps, const unsigned int _output_rate)
{
    steps = _steps;
    entropy_tank.assign(_output_rate, 0);
}
#+END_SRC

*** Applying the Permutation
This is straightforward: we simply take the reference implementation
on [[https://github.com/cryptolu/sparkle/blob/master/software/sparkle/sparkle.c][github]]!
#+BEGIN_SRC cpp :tangle sparklyRG/sparkle512.cpp
void Sparkle512core::_permute()
{
    unsigned int i, j;  // Step and branch counter
    uint32_t rc, tmpx, tmpy, x0, y0;
  
    for(i = 0; i < steps; i ++) {
	// Add round constant
	state[1] ^= RCON[i % N_BRANCHES];
	state[3] ^= i;
	// ARXBOX layer
	for(j = 0; j < 2*N_BRANCHES; j += 2) {
	    rc = RCON[j>>1];
	    state[j] += ROT(state[j+1], 31);
	    state[j+1] ^= ROT(state[j], 24);
	    state[j] ^= rc;
	    state[j] += ROT(state[j+1], 17);
	    state[j+1] ^= ROT(state[j], 17);
	    state[j] ^= rc;
	    state[j] += state[j+1];
	    state[j+1] ^= ROT(state[j], 31);
	    state[j] ^= rc;
	    state[j] += ROT(state[j+1], 24);
	    state[j+1] ^= ROT(state[j], 16);
	    state[j] ^= rc;
	}
	// Linear layer
	tmpx = x0 = state[0];
	tmpy = y0 = state[1];
	for(j = 2; j < N_BRANCHES; j += 2) {
	    tmpx ^= state[j];
	    tmpy ^= state[j+1];
	}
	tmpx = ELL(tmpx);
	tmpy = ELL(tmpy);
	for (j = 2; j < N_BRANCHES; j += 2) {
	    state[j-2] = state[j+N_BRANCHES] ^ state[j] ^ tmpy;
	    state[j+N_BRANCHES] = state[j];
	    state[j-1] = state[j+N_BRANCHES+1] ^ state[j+1] ^ tmpx;
	    state[j+N_BRANCHES+1] = state[j+1];
	}
	state[N_BRANCHES-2] = state[N_BRANCHES] ^ x0 ^ tmpy;
	state[N_BRANCHES] = x0;
	state[N_BRANCHES-1] = state[N_BRANCHES+1] ^ y0 ^ tmpx;
	state[N_BRANCHES+1] = y0;
    }
}
#+END_SRC

*** Squeezing into the Entropy Tank
In order to further break the correlation between the successive
outputs of the sponge, we don't use a basic squeezing. Instead, we use
an indirect squeezing, as explained [[*Indirect Squeezing][above]]. We add the bytes to the
=entropy_tank= branch by branch, so 8 by 8.
#+BEGIN_SRC cpp :tangle sparklyRG/sparkle512.cpp
void Sparkle512core::_squeeze()
{
    uint32_t tmp;
    for (unsigned int i=0; i<entropy_tank.size(); i += 64)
    {
	unsigned int k = i / 32; // index in the state
	// dealing with x
	tmp = state[k] ^ state[(k+4) % (2*N_BRANCHES)] ^ state[(k+10) % (2*N_BRANCHES)] ;
	for(unsigned int j=0; j<32; j++)
	    entropy_tank[i+j] = (tmp >> j) & 0x1;
	// dealing with y
	tmp = state[k+1] ^ state[(k+5) % (2*N_BRANCHES)] ^ state[(k+11) % (2*N_BRANCHES)] ;
	for(unsigned int j=0; j<32; j++)
	    entropy_tank[i+32+j] = (tmp >> j) & 0x1;
    }
    entropy_cursor = 0;
}
#+END_SRC
*** Absorbing Seeds
We simply XOR the content of the =byte_array= input into the internal
state.

We do not implement indirect injection, instead we simply apply the
permutation three times (with the addition of some domain separating
constants in the capacity in-between).

Note that this method can only handle inputs smaller than the 
#+BEGIN_SRC cpp :tangle sparklyRG/sparkle512.cpp
void Sparkle512core::absorb(const std::vector<uint8_t> byte_array)
{
    for(unsigned int i=0; i<byte_array.size(); i+=4)
	for(unsigned int j=0; j<4; j++)
	    state[i >> 2] ^= ((uint32_t)byte_array[i + j]) << (8*j) ;
    _permute();
    state[state.size()-1] ^= 1;
    _permute();
    state[state.size()-1] ^= 2;
    _permute();
};


#+END_SRC
** Getting Fixed Bit-length Outputs
In general, the goal is to return a 64-bit unsigned integer whose bits
of low weight correspond to a uniformly generated pseudo-random number
with a specified bit-length. As the =entropy_tank= contains bits, this
is easily achieved with some bit-fiddling.

#+BEGIN_SRC cpp :tangle sparklyRG/sparkle512.cpp
uint64_t Sparkle512core::get_n_bit_unsigned_integer(const unsigned int n)
{
    uint64_t result = 0;
    for (unsigned int i=0; i<n; i ++)
    {
	if (entropy_cursor == entropy_tank.size())
	{
	    _permute();
	    _squeeze();
	}
	result <<= 1;
	result |= entropy_tank[entropy_cursor];
	entropy_cursor ++;
    }
    return result;
}
#+END_SRC

* Calling the Core from SAGE
In order to work, this module must be compiled. This achieved using
the following shell command:
#+BEGIN_SRC sh
sage setup.py build_ext --inplace
#+END_SRC

However, for this compilation to work in the first place, we need to
do write bunch of boilerplate in a bunch of different files.

** Declaration
The C++ functions and classes that we want to be able to reach from
SAGE must first be declared in the =.pxd= file. It first imports the
relevant data types from some built-in python libraries (=libcpp= and
=libc=). We only need C++ vectors and some fixed-length integers.

#+BEGIN_SRC python :tangle sparklyRG/declaration.pxd
from libcpp.vector cimport vector
from libc.stdint cimport uint64_t, uint8_t
#+END_SRC

We then declare the class we want to reach, namely
=Sparkle512core=. It is declared in the header file, but its source
code in the =cpp= file so that's the one we refer to here.

#+BEGIN_SRC python :tangle sparklyRG/declaration.pxd
cdef extern from "./sparkle512.cpp":
    cdef cppclass Sparkle512core:
        Sparkle512core() except +
        void setup(const unsigned int steps, const unsigned int)
        void absorb(const vector[uint8_t])
        uint64_t get_n_bit_unsigned_integer(const unsigned int n)

#+END_SRC

** Wrapping
The C++ code can now be reached from SAGE to some extent, but in order
for it to be importable in a regular script we need to wrap it. This
is done by in a =.pyx= file.

We first need to =cimport= (not =import=!) the content of the
declaration file we just created. Then, in order for SAGE to be able
to use the C++ =Sparkle512core= class, we build a custom class,
=SparkleRG=. It will then itself be wrapped later in such a way as to
provide relevant parameter choices.

#+BEGIN_SRC python :tangle sparklyRG/wrapper.pyx
from declaration cimport *

cdef class SparkleRG:
    cdef Sparkle512core core
    
    def __init__(self, steps, output_rate):
        self.core = Sparkle512core()
        self.core.setup(steps, output_rate)

    def absorb(self, x):
        # handling padding
        to_absorb = x + bytearray([0] * (48 - len(x)))
        self.core.absorb(to_absorb)

    def get_n_bit_unsigned_integer(self, n):
        return self.core.get_n_bit_unsigned_integer(n)
#+END_SRC

** Compiling

By now, the structure of the code is clear for SAGE. We then need to
compile it. The following is essentially boiler plate that was written
by one of my interns (Matthias Joly, thanks to him!) for [[https://github.com/lpp-crypto/sboxU][sboxU]]. It
specifies the options to give to the compiler (in particular, =O3=: we
want speed!).

A warning: it is crucial that the name given to the extension (the
first argument when constructing the =Extension= object) is the same
as the name of wrapper file! Otherwise, it will silently fail. Beware!
#+BEGIN_SRC python :tangle sparklyRG/setup.py
from setuptools import setup
from distutils.core import Extension
from Cython.Build import cythonize
import os
from sys import platform

if platform == 'darwin':    #macOs
    os.environ["CC"] = "clang"
    os.environ["CXX"] = "clang"
else:
    os.environ["CC"] = "g++"
    os.environ["CXX"] = "g++"
    extra_compile_args = ["-O3", "-march=native", "-std=c++17", "-pthread", "-Wall"]
    extra_link_args=[]

HOME = os.path.expanduser('~')
if platform == 'darwin':
    extra_compile_args += ['-lomp', '-I/usr/local/opt/libomp/include']
    extra_link_args += ['-lomp', '-L/usr/local/opt/libomp/include']
else:
    extra_compile_args += ['-fopenmp']
    extra_link_args += ['-fopenmp']



module_sparklyRG = Extension("wrapper",
                             sources=["wrapper.pyx"],
                             libraries=[],
                             include_dirs=['.'], 
                             language='c++',
                             extra_link_args=extra_link_args,
                             extra_compile_args=extra_compile_args)


setup(name='wrapper', ext_modules=cythonize([module_sparklyRG], language_level = "3"))
#+END_SRC

** Making a module
We are going to provide additional functionalities in the module, but
for now we simply create the necessary file so that we can run some
tests on the =SparkleRG= low-level class.

#+BEGIN_SRC python :tangle sparklyRG/__init__.py
from .wrapper import *
#+END_SRC

** Testing
Running the following SAGE script will let us see what the output of
the PRNG looks like with just 3 rounds of mixing.

#+BEGIN_SRC python :tangle test_sparkle_core.py
#!/usr/bin/sage

from sage.all import *
from sparklyRG import *

prg = SparkleRG(3, 384)

s = 0
print("| # perm | n | output | HW | length deficit |")
print("|-")
for n in range(0, 64):
    s += n
    x = prg.get_n_bit_unsigned_integer(n)
    print("| {} | {} | {} | {} | {} |".format(
        floor(s / 384),
        n,
        hex(x),
        Integer(x).popcount(),
        n - Integer(x).bit_length()
    ))
#+END_SRC

Here is the result (obvious, a nice looking org-table!):

| # perm |  n |             output | HW | length deficit |
|--------+----+--------------------+----+----------------|
|      0 |  0 |                0x0 |  0 |              0 |
|      0 |  1 |                0x0 |  0 |              1 |
|      0 |  2 |                0x0 |  0 |              2 |
|      0 |  3 |                0x0 |  0 |              3 |
|      0 |  4 |                0x0 |  0 |              4 |
|      0 |  5 |                0x0 |  0 |              5 |
|      0 |  6 |                0x0 |  0 |              6 |
|      0 |  7 |                0x0 |  0 |              7 |
|      0 |  8 |                0x0 |  0 |              8 |
|      0 |  9 |                0x0 |  0 |              9 |
|      0 | 10 |                0x0 |  0 |             10 |
|      0 | 11 |                0x0 |  0 |             11 |
|      0 | 12 |                0x0 |  0 |             12 |
|      0 | 13 |                0x0 |  0 |             13 |
|      0 | 14 |                0x0 |  0 |             14 |
|      0 | 15 |                0x0 |  0 |             15 |
|      0 | 16 |                0x0 |  0 |             16 |
|      0 | 17 |                0x0 |  0 |             17 |
|      0 | 18 |                0x0 |  0 |             18 |
|      0 | 19 |                0x0 |  0 |             19 |
|      0 | 20 |                0x0 |  0 |             20 |
|      0 | 21 |                0x0 |  0 |             21 |
|      0 | 22 |                0x0 |  0 |             22 |
|      0 | 23 |                0x0 |  0 |             23 |
|      0 | 24 |                0x0 |  0 |             24 |
|      0 | 25 |                0x0 |  0 |             25 |
|      0 | 26 |                0x0 |  0 |             26 |
|      0 | 27 |                0x0 |  0 |             27 |
|      1 | 28 |           0x2afdd0 | 13 |              6 |
|      1 | 29 |         0x1d76fe0a | 18 |              0 |
|      1 | 30 |          0xc1221ca | 10 |              2 |
|      1 | 31 |         0x5ecafbe9 | 21 |              0 |
|      1 | 32 |         0x2468e67f | 17 |              2 |
|      1 | 33 |        0x1ce5f2452 | 17 |              0 |
|      1 | 34 |        0x11a22e9ed | 17 |              1 |
|      1 | 35 |        0x266d47fdc | 21 |              1 |
|      1 | 36 |        0xfca257eab | 22 |              0 |
|      1 | 37 |       0x1ac0337643 | 17 |              0 |
|      1 | 38 |        0xc442b3600 | 12 |              2 |
|      2 | 39 |       0x13a3867729 | 19 |              2 |
|      2 | 40 |       0x567d857a77 | 24 |              1 |
|      2 | 41 |       0x6d0ef5e35d | 24 |              2 |
|      2 | 42 |       0x18713c01e3 | 16 |              5 |
|      2 | 43 |      0x666f409e7b1 | 23 |              0 |
|      2 | 44 |      0x8ba14cc2d96 | 20 |              0 |
|      2 | 45 |     0x1de52cf52f1a | 26 |              0 |
|      2 | 46 |     0x206c955e87ee | 24 |              0 |
|      2 | 47 |     0x664623185716 | 20 |              0 |
|      3 | 48 |     0xfaaad4db0060 | 22 |              0 |
|      3 | 49 |      0x48d56e20234 | 17 |              6 |
|      3 | 50 |    0x1a1e77205b369 | 25 |              1 |
|      3 | 51 |    0x683218e45fbd1 | 25 |              0 |
|      3 | 52 |    0xa71310ba4b80a | 21 |              0 |
|      3 | 53 |    0x24d1cd36484a7 | 23 |              3 |
|      3 | 54 |   0x24b310db07cc68 | 24 |              0 |
|      4 | 55 |   0x1df022818bd645 | 24 |              2 |
|      4 | 56 |   0x8ce5895c2bed61 | 28 |              0 |
|      4 | 57 |  0x1e9796a1ee0b246 | 29 |              0 |
|      4 | 58 |   0x50c264a0c92bc7 | 23 |              3 |
|      4 | 59 |  0x787e05b3144d582 | 27 |              0 |
|      4 | 60 |  0xa85d9de1dc7c376 | 34 |              0 |
|      4 | 61 |  0x5f618ad67614361 | 29 |              2 |
|      5 | 62 | 0x2b01e54da6bf702f | 33 |              0 |
|      5 | 63 |  0x8ccabd177a0e7d7 | 34 |              3 |

It is as expected: the sponge is not seeded, so we start with only
zeroes until the permutation is finally called. Then, we have balanced
looking outputs of a plausible length.

* The SparklyRG module
#+BEGIN_SRC python :tangle sparklyRG/__init__.py
# some logic
#+END_SRC

