#!/usr/bin/sage
#-*- Python -*-
# Time-stamp: <2024-08-02 14:36:12 lperrin> 

import datetime

from collections import defaultdict


# !SECTION! Setting up default parameters and the context 
# =======================================================

# !SUBSECTION! Is SAGE used? 

# Handling different cases depending on whether the program is called
# from SAGE or from python. The main difference between both cases is
# that SAGE brings in more types, that then must be handled when
# printing data.

# to figure out if the class is called from SAGE or from Python, we
# try importing SAGE.
try:
    import sage
    IS_SAGE = True
except:
    IS_SAGE = False

# In SAGE, there are more number types than in plain python
if IS_SAGE:
    from sage.all import *
    int_types = (int, Integer)
    float_types = (float, sage.rings.real_mpfr.RealNumber)
else:
    int_types = (int)
    float_types = (float)
    from math import floor # needed when computing elapsed time
    

# !SECTION! Printing
# ==================

# !SUBSECTION! Default strings

# The default strings used when printing both to stdout and to files
INDENT = " "
DEFAULT_INT_FORMAT = "{:3d}"
DEFAULT_FLOAT_FORMAT = "{:8.3e}"


# !SUBSECTION!  Printing functions

# Several functions that print their input in a pretty way, either for
# humain readability or for Python readability.

def pretty_result(r,
                  int_format=DEFAULT_INT_FORMAT,
                  float_format=DEFAULT_FLOAT_FORMAT,):
    """Outputs a human readable pretty string representating the input
    `r`.

    It is intended to play well with stdout output as well as both
    markdown and org.
    
    Inputs:

    - `r`: the information to print.

    - `int_format` (defaults to DEFAULT_INT_FORMAT): the format string
      used to print integers (and associated types).
    
    - `float_format` (defaults to DEFAULT_INT_FORMAT): the format
      string used to print floats (and associated types).

    """
    if isinstance(r, dict) or isinstance(r, defaultdict):
        result = ""
        for k in sorted(r.keys()):
            result += "{}={}, ".format(pretty_result(k), pretty_result(r[k]))
        return result[:-2]
    elif (isinstance(r, list) and len(r) > 0):
        if isinstance(r[0], list):
            # case of a matrix as a list of list
            result = "table:\n"
            for row in r:
                for x in row:
                    result += "| {} ".format(pretty_result(x))
                result += "|\n"
            return result
        else:
            # case of a plain list
            return str(r)
    elif isinstance(r, int_types):
        return int_format.format(r)
    elif isinstance(r, float_types):
        return float_format.format(r)
    elif IS_SAGE:
        if "sage.matrix" in str(type(r)):
            return pretty_result([[x for x in row] for row in r.rows()])
        else:
            pass
    return str(r)
    

def python_readable_string(y):
    """Returns a string representation of `y` that is both human
    readable *and* Python readable.

    It is supposed to look like the code a human would write to
    generate a variable equal to `y`.

    Input:

    - `y`: the data to print

    """
    if isinstance(y, list):
        result = "["
        for x in y:
            result += "{}, ".format(python_readable_string(x))
        return result[:-2] + "]"
    elif isinstance(y, str):
        return '"{}"'.format(y)
    elif isinstance(y, dict):
        result = "{"
        for k in y.keys():
            result += "{}: {}, ".format(python_readable_string(k),
                                        python_readable_string(y[k]))
        return result[:-2] + "}"
    elif IS_SAGE:
        if "sage.matrix" in str(type(y)):
            return "Matrix({}, {}, {})".format(
                y.nrows(),
                y.ncols(),
                str(y.rows())
            )
        else:
            pass
    return str(y)
            
        

# !SECTION! The LogBook class

class LogBook:
    """A class helping with keeping track of the data generated while
    a script is running.

    It does so by generating a pretty output while it is run (which
    can be printed in real-time), and as a file in a convenient markup
    format (either markdown or orgmode).

    It keeps track of two distinct things:

    - "story" (stored in `self.story`), which is simply a list of
      events intended to describe *how* the script is running. Its
      elements are either headings (with a given depth), or pairs
      (time-stamp, string). The time-stamps are generated
      automatically. It is output to stdout if `verbose` is set to
      True, and to a specified file.
    
    - "results" (stored in `self.results`), which are intended to
      correspond to the specific data that was intended to be
      generated by the script. They are added to the "story" as they
      are generated. Optionnally, a python script regenerating them
      can be generated as well, the idea being to ease
      post-processing: said python script can simply be imported to
      reobtain the `results`.

    Inputs:
    
    - `file_name`: the path to the file in which the logbook should be
      written.

    - `title`: the title of the logbook, defaults to "Experiment". Try
      to give a meaningful one, it will help in the long term.

    - `verbose`: if set to True, the logbook is printed in stdout as
      it is written. Defaults to True.

    - `print_format`: the style to use when printing (both to the file
      and in stdout if `verbose` is set to True); defaults to "md" for
      Markdown, and can also be equal to "org" for orgmode.

    - `result_file`: the file in which the `results` will be
      written. Defaults to `None`, meaning that no such file is
      generated.

    - `with_time`: if set to True, the time during which the LogBook
      is used is computed and output in the end. Defaults to True.

    - `with_mem`: if set to True, the maximum memory used while the
      LogBook is used is computed and output in the end. Defaults to
      True.
    

    Usage:

    with LogBook(args*) as lgbk:
        lgbk.section(1, "starting up") # 1 indicates the heading level,
                                       # with 1 being highest, then 2...
        # ... do stuff
        lgbk.log_event("string")
        # the string will be added to the `story` with a time-stamp
        lgbk.log_result(data)
        # `data` will be added to the `results` (and this fact will also
        # be added to the `story`)

    """


    # !SUBSECTION! Initialization
    
    def __init__(self,
                 file_name,
                 title="Experiment",
                 verbose=True,
                 print_format=None,
                 result_file=None,
                 with_time=True,
                 with_mem=True
                 ):
        # figuring out the proper file name and inferring the
        # print_format if it is not specified
        self.result_file = result_file
        if print_format == None:
            if file_name[-2:] == "md":
                self.print_format = "md"
            else:
                self.print_format = "org"
        else:
            self.print_format = "md" # defaulting to markdown
        self.file_name = file_name
        if self.file_name[-len(self.print_format)-1:] != "."+self.print_format:
            self.file_name += "." + self.print_format
        # setting up displaying infrastructure
        self.verbose = verbose
        self.current_toc_depth = 0
        if self.print_format == "org":
            self.headings = lambda depth : "*" * depth
            self.bullet = "-"
            self.pretty_title = "#+TITLE: " + title
        elif self.print_format == "md":
            self.headings = lambda depth : "#" * (depth + 1)
            self.bullet = "*"
            self.pretty_title = "{}\n{}".format(title, "="*len(title))
        else:
            raise Exception("unsuported print format: {}".format(self.print_format))
        # initializing the state
        self.title = title
        self.with_time = with_time
        self.with_mem = with_mem
        self.results = []
        self.story = []
        if self.with_mem:
            import tracemalloc
            self.mem_tracer = tracemalloc


    # !SUBSECTION! Logging events and results
    
    def section(self, depth, heading):
        self.story.append([depth, heading])
        self.current_toc_depth = depth
        if self.verbose:
            print("{}{} {}".format(
                "\n\n" if depth == 1 else "\n" if depth == 2 else "",                
                self.headings(depth),
                heading
            ))
        
        
    def log_event(self, event):
        # !TODO! more sophisticated grammar to handle non-lists, enumerations, etc
        
        # Mockup: lgbk.log_event("n*", "truc") logs "truc" in a
        # numbered list (possibly starting a new one if necessary) and
        # without a time-stamp.
        timed_event = [
            datetime.datetime.now().isoformat(" ").split(".")[0],
            event
        ]
        self.story.append(timed_event)
        if self.verbose:
            print("{} {} [{}] {}".format(
                INDENT * self.current_toc_depth,
                self.bullet,
                timed_event[0],
                timed_event[1],
            ))

            
    def log_result(self, result):
        self.results.append(result)
        self.log_event("[result] " + pretty_result(result))

        
    def save_to_file(self):
        with open(self.file_name, "w") as f:
            f.write("{}\n".format(self.pretty_title))
            f.write("Experimental log generated on the {}.\n\n".format(
                datetime.datetime.now().strftime("%a. %b. %Y at %H:%M")
            ))
            for line in self.story:
                if isinstance(line, list):
                    if isinstance(line[0], str): # case of a time-stamp
                        f.write("{} [{}] {}\n".format(self.bullet,
                                                      line[0],
                                                      line[1]))
                    else: # case of a heading
                        depth = line[0]
                        f.write("{}{} {}\n".format(
                            "\n\n" if depth == 1 else "\n" if depth == 2 else "",                
                            self.headings(depth),
                            line[1]
                        ))
                else:
                    f.write("{} {}\n".format(self.bullet, str(line)))


    # !SUBSECTION!  The functions needed by the "with" logic

    def __enter__(self):
        if self.with_time:
            self.start_time = datetime.datetime.now()
        if self.with_mem:
            self.mem_tracer.start()
        if self.verbose:
            print(self.title + "\n")
        return self
    

    def __exit__(self, *args):
        self.section(1, "Finished")
        if self.with_time or self.with_mem:
            self.section(2, "Performances")
        # handling time complexity
        if self.with_time:
            elapsed_time = datetime.datetime.now() - self.start_time
            tot_secs = floor(elapsed_time.total_seconds())
            days = floor(tot_secs / 86400)
            hours = floor((tot_secs % 86400) / 3600)
            minutes = floor((tot_secs % 3600) / 60)
            seconds = (tot_secs % 60) + elapsed_time.total_seconds() - tot_secs
            elapsed_time_description = "elapsed time: {}s ({})".format(
                elapsed_time.total_seconds(),
                "{:d}d {:02d}h {:02d}m {:5.03f}s".format(
                    days,
                    hours,
                    minutes,
                    seconds
            ))
            self.story.append(elapsed_time_description)
            if self.verbose:
                print(self.bullet + " " + elapsed_time_description)
        # handling memory complexity
        if self.with_mem:       
            memory_size, memory_peak = self.mem_tracer.get_traced_memory()
            self.mem_tracer.stop()
            if memory_peak > 1024**3:
                pretty_peak = "(= {:.2f}GB)".format(memory_peak / 1024**3)
            elif memory_peak > 1024**2:
                pretty_peak = "(= {:.2f}MB)".format(memory_peak / 1024**2)
            elif memory_peak > 1024:
                pretty_peak = "(= {:.2f}kB)".format(memory_peak / 1024)
            else:
                pretty_peak = ""
            memory_description = "peak memory usage: {}B {}".format(
                memory_peak,
                pretty_peak
            )
            self.story.append(memory_description)
            if self.verbose:
                print(self.bullet + " " + memory_description)
        # handling results
        # -- in the logbook itself
        if len(self.results) == 0:
            results_description = "no results found"
        else:
            results_description = "{:d} result(s) found".format(len(self.results))
            self.section(2, results_description)
            number_length = len(str(len(self.results)))
            counter = 0
            for res in self.results:
                pretty_res = pretty_result(res)
                self.story.append(pretty_res)
                print("{}{:d}. {}{}".format(
                    INDENT,
                    counter,
                    " "*(number_length - len(str(counter))),
                    pretty_res
                ))
                counter += 1
        self.save_to_file()
        # -- in the separated file (if relevant)
        if self.result_file != None:
            with open(self.result_file, "w") as f:
                f.write("# Output of \"{}\", generated on {}\n".format(
                    self.title,
                    datetime.datetime.now().isoformat(" ").split(".")[0]
                ))
                f.write("# see LogBook at {}\n".format(self.file_name))
                if IS_SAGE:
                    f.write("from sage.all import *\n\n")
                f.write("results = [\n")
                counter = 0
                for x in self.results:
                    f.write("{},    # {:d}\n".format(
                        python_readable_string(x),
                        counter
                    ))
                    counter += 1
                f.write("]\n")
            if self.print_format == "org":
                self.section(2, "results written to [[./{}][{}]".format(
                    self.result_file,
                    self.result_file
                ))
            else:
                self.section(2, "results written to {}".format(
                    self.result_file
                ))

                
            
        

# !SECTION!  Main program testing the LogBook class

if __name__ == "__main__":
    # generating a dummy logbook
    with LogBook("logbook.org",
                 verbose=True,
                 result_file="res.py",
                 ) as lgbk:
        lgbk.section(1, "starting up")
        lgbk.log_event("bli")
        lgbk.log_event("blu")
        blu = []
        for x in range(0, 2**5):
            blu.append(x**3)
        lgbk.log_result(sum(blu))
        lgbk.log_result({
            "sum of cubes": sum(x**3 for x in blu),
            "sum of squares": sum(x**2 for x in blu)
        })
        for x in range(0, 12):
            lgbk.log_result({"padding" : x})
        if IS_SAGE:
            lgbk.log_result(Matrix([[0, 1], [2,300000]]))
        else:
            lgbk.log_result([[0, 1], [2,300000]])
        lgbk.section(2, "loading stuff")
        lgbk.log_event("bli bla blu")
        lgbk.section(1, "investigating")

    # testing reimport of the results
    import res
    print(res.results)
